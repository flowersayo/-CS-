# DB 세션에 대해서 설명해주세요.

사용자가 데이터베이스에 연결되어 있는 상태를 나타낸다. ( DB와 클라이언트 간의 논리적인 연결 )

세션 내부에는 여러개의 트랜잭션이 존재할 수 있으며, 일반적으로 데이터베이스는 여러 곳에서 동시에 접근하여 수 많은 세션이 동시에 연결되어 있다. 

# Commit에 대해서 설명해주세요.

트랜잭션의 수행이 성공적으로 완료되었음을 선언하는 연산이다. commit 연산이 실행된 후에야 트랜잭션의 수행 결과가 실제 데이터베이스에 반영되어 일관된 상태를 유지하게 된다.

# Rollback에 대해서 설명해주세요.

트랜잭션이 수행되는 도중에 장애가 발생했을 때 rollback 연산을 실행하여 트랜잭션 수행 전의 일관된 상태로 되돌릴 수 있다.

# Auto Commit 설정에 대해서 설명해주세요.

트랜잭션이 자동으로 커밋되도록 하는 설정이다. 일반적으로 개발자는 트랜잭션의 커밋을 명시적으로 지정해야하나 ‘auto commit; 을 설정하면, 각 SQL 문이 실행될 때마다 트랜잭션이 자동으로 커밋된다.

그러나 한번 커밋이 된 트랜잭션은 Rollback 이 불가능하므로 주의해야한다. 

# 트랜잭션에 대해 설명해주세요.

작업 하나를 수행하는데 필요한 데이터베이스의 연산을 모아놓은 것으로, 데이터베이스의 논리적 작업의 단위이다. 

# 트랜잭션의 성질 ACID에 대해서 설명해주세요.

- **원자성(Atomicity)**: 트랜잭션 내의 연산들은 **모두 정상적으로 실행되거나 하나도 실행되지 않아야 한다**는 규칙을 말한다.
- **일관성(Consistency):** 트랜잭션이 수행된 후에도 데이터베이스가 **제약 조건을 유지하는 일관된 상태**여야 한다.
- **격리성,고립성(Isolation) :** 현재 수행 중인 트랜잭션이 완료될 때까지 **트랜잭션이 생성한 중간 연산 결과에 다른 트랜잭션들이 접근할 수 없다.**
- **지속성(Durability) :** 트랜잭션이 완료된 후 데이터베이스에 반영한 **수행결과는 어떠한 경우에도 손실되지 않고 영구적**이어야한다.

# MVCC(Multi-Version Concurrency Control)이란?

Lock-based 방식은 동일한 데이터에 대해 읽기와 쓰기를 동시에 수행하면 한 작업이 실행되는 동안 다른 작업이 블록되어 전체 처리량이 저하되고 성능 문제가 발생할 수 있다. 이러한 단점을 보완하기 위해 동시성을 제어하는 새로운 방법인 MVCC 가 등장했다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b19e4487-dfef-4395-9201-8b3dc303ca25/0263a338-956e-4191-a577-3c5f6cd248ae/Untitled.png)

- 데이터에 접근하는 사용자는 데이터를 읽을 때 접근한 시점 기준으로 가장 최근에 커밋된 데이터를 읽는다. (Snapshot)
- snapshot 데이터에 대한 변경이 완료(commit) 될 때까지의 중간 변경사항은 다른 사용자가 볼 수 없다.
- 오늘 날 대부분의 RDBMS 는 MVCC 기반으로 동작한다.

# 트랜잭션 격리 수준이 뭘까요?

동시에 여러 트랜잭션이 실행될 때 발생할 수 있는 **데이터 불일치 문제를 관리하기 위해 사용되는 개념**이다. 각 트랜잭션이 다른 트랜잭션에 의해 **어떻게 영향을 받는지**를 정의한다.

# 트랜잭션 격리 수준 SERIALIZABLE에 대해서 설명해주세요.

가장 엄격한 격리 수준. 트랜잭션을 **순차적으로 진행**시킨다. 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없으므로, 독립적으로 수행되며 어떠한 데이터 부정합 문제도 발생하지 않는다. 그러나 동시성을 낮추고 성능에 영향을 미친다.

# 트랜잭션 격리 수준 READ UNCOMMITTIED에 대해서 설명해주세요.

가장 낮은 격리 수준. **하나의 트랜잭션이 다른 트랜잭션에서 아직 커밋되지 않은 변경사항을 읽을 수 있다.** 이로 인해 *Dirty Read(더티 리드) 현상이 발생할 수 있다.

*Dirty Read : 어떤 트랜잭션의 작업이 완료되지 않았는데도, 다른 트랜잭션에서 보이는 데이터 부정합 문제. 데이터가 조회되었다가 사라지는 현상을 초래한다.

# 트랜잭션 격리 수준 READ COMMITTED에 대해서 설명해주세요.

**하나의 트랜잭션이 다른 트랜잭션에서 커밋된 변경사항만을 읽을 수 있다.** Dirty Read(더티 리드)를 방지하지만 Non-Repeatable Read와 *Phantom Read 문제가 발생할 수 있다.

*SELECT로 조회한 경우 트랜잭션이 끝나기 전에 **다른 트랜잭션에 의해 추가된 레코드가 발견**되는 현상

# 트랜잭션 격리 수준 REPEATABLE READ에 대해서 설명해주세요.

트랜잭션이 시작할 때 읽은 데이터는 해당 트랜잭션이 종료될 때까지 일관성 있게 유지된다. 

즉, 한 트랜잭션에서 동일한 쿼리를 실행했을 때 결과가 항상 같음을 보장한다. Non-Repeatable Read는 방지하지만, Phantom Read 문제가 발생할 수 있다. 하지만 MVCC 에서는  자신보다 나중에 실행된 트랜잭션이 추가한 레코드는 무시하면 되기때문에 Phantom Read는 발생하지 않는다. SELECT 이후 SELECT FOR UPDATE 를 실행하는 경우, 팬텀 리드가 발생한다.

# DB 동시성 제어에 대해서 설명해주세요.

동시에 같은 데이터에 접근하여 변경 연산을 시도하려고 하면 예상치 못한 결과가 나타날 수 있다. 따라서 병행 수행을 하더라도 각 트랜잭션이 다른 트랜잭션의 방해를 받지 않고 정확한 수행 결과를 얻을 수 있도록 제어해야 하는데 이를 동시성 제어라고 한다. 보통 여러 트랜잭션이 차례로 번갈아 수행되는 인터리빙 방식으로 이루어진다. 

# 갱신 손실 문제에 대해 설명해주세요.

하나의 트랜잭션이 수행한 **데이터 변경 연산의 결과를 다른 트랜잭션이 덮어써 변경 연산이 무효화 되는 것을 말한다.**

# DB 락에 대해서 설명해주세요.

트랜잭션들이 **동일한 데이터에 동시에 접근하지 못하도록 lock과 unlock이라는 2개의 연산을 이용해 제어**한다. **한 트랜잭션이 먼저 접근한 데이터에 대한 연산을 모두 마칠 때까지, 해당 데이터에 다른 트랜잭션이 접근하지 못하도록 상호 배제하여 직렬 가능성을 보장**하는 것이다. 이 두 연산을 활용해서 다른 트랜잭션의 방해를 받지 않고 데이터에 독점적으로 접근할 수 있게 된다.

| 연산 | 설명 |
| --- | --- |
| 공용락, 공유락(Shared Lock) |  트랜잭션이 데이터에 대해 공용 lock 연산을 실행하면, 해당 데이터에 read 연산을 실행할 수 있지만 write 연산은 실행할 수 없다. 그리고 해당 데이터에 다른 트랜잭션도 공용 lock 연산을 동시에 실행할 수 있다.
(데이터에 대한 사용권을 여러 트랜잭션이 함께 가질 수 있음)

ex) SELECT ~ FOR SHARE |
| 전용락, 배타락(Exclusive Lock) | 트랜잭션이 데이터에 대해 전용 lock 연산을 실행하면, 해당 데이터에 read, write 연산 모두 실행할 수 있다. 그러나 해당 데이터에 다른 트랜잭션은 공용이든 전용이든 어떤 lock 연산도 실행할 수 없다.
(전용 lock 연산을 실행한 트랜잭션만 해당 데이터에 대한 독점권을 가질 수 있음) 

ex) SELECT ~ FOR UPDATE |

# DB 데드락에 대해서 설명해주세요.

**트랜잭션들이 상대가 독점하고 있는 데이터에 unlock 연산이 실행되기를 서로 기다리면서 수행을 중단하고 있는 상태**이다.  **교착 상태**에 빠지면 트랜잭션들은 더 이상 수행하지 못하고 상대 트랜잭션이 먼저 unlock 연산을 실행해주기를 한없이 기다리게 된다. 예를 들어 트랜잭션 T1과 T2가 모두 데이터 X 와 데이터 Y 에 접근하는 상황이 있다. 트랜잭션 T1 은 T2가 lock한 데이터 X에 접근하기 위해 T2가 unlock 연산을 실행해주기를 기다리고 있고, T2는 T1이 lock한 데이터 Y에 접근하기 위해 T1이 unlock 연산을 실행해주기를 기다리고 있다.

# DB 회복에 대해서 설명해주세요.

데이터베이스에 장애가 발생했을 때 **장애가 발생하기 전의 모순이 없고 일관된 상태로 복구시키는 것**을 말한다. **덤프** 또는 **로그** 방법을 사용해 **데이터를 복사**해 두었다가 회복시킬 때 복사본을 사용한다.

# REDO, UNDO에 대해서 설명해주세요.

- **Redo(재실행)** : 가장 최근에 저장한 데이터베이스 복사본을 가져온 후 로그에 기록된 그 이후에 실행된 모든 변경 연산을 재실행하여 장애가 발생하기 직전의 데이터베이스 상태로 복구한다.
- **Undo(취소)** : 로그에 기록된 변경 연산 이전의 값을 이용하여 **지금까지 실행된 모든 변경 연산을 취소**하여 데이터베이스를 원래의 상태로 복구한다.
    
    

# 체크포인트 회복 기법에 대해서 설명해주세요.

**로그 전체를 대상으로 회복 기법을 적용하면 데이터베이스 회복에 너무 많은 시간**이 걸리고 redo 연산을 수행할 필요가 없는 트랜잭션에도 redo 연산을 실행하는 일이 발생하므로 비효율적이다. 따라서 로그 회복 기법과 같은 방법으로 로그 기록을 이용하되, **일정 시간 간격으로 검사 시점**을 만들어둔다. 그리고 장애가 발생하면 **가장 최근 검사 시점** 이전의 트랜잭션에는 회복 작업을 수행하지 않고, **이후의 트랜잭션에만 회복 작업을 수행하도록 하는 기법**이다. **회복 작업의 범위가 검사 시점 이후**로 정해지므로 **불필요한 회복 작업을 수행하지 않아 데이터베이스 회복 시간이 단축된다는 장점**이 있다.

# MySQL InnoDB의 기본 트랜잭션 고립 수준은 뭘까요?

Repeatable Read이다. 이는 동일한 트랜잭션 내에서 반복 가능한 읽기를 지원하며, 한 번 읽은 데이터는 트랜잭션이 종료될 때까지 변경되지 않는다.
