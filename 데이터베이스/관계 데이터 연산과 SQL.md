# SQL에 대해서 설명해주세요. C언어와 같은 프로그래밍 언어와 어떤차이가 있나요?

SQL은 관계형 데이터베이스에서 **데이터를 관리하고 조작**하기 위한 표준화된 언어입니다. SQL은 데이터베이스를 생성, 수정, 삭제하고 데이터를 조회하는 데 사용됩니다. C언어는 **절차적** 프로그래밍 언어로, 명령의 순서와 흐름을 명시적으로 제어하는 반면, SQL은 사용자가 처리를 원하는 데이터가 무엇인지 제시하면 데이터베이스 시스템이 처리 방법을 자동으로 결정하는 **비절차적(선언적)** 데이터 언어라는 차이점이 있습니다.

# 개발자가 작성한 SQL이 어떤 과정을 통해 실행 되는지 설명해주세요.
![Untitled (4)](https://github.com/flowersayo/-CS-/assets/86418674/1b5cfbe5-4174-499a-83a6-15f9b9e90e2b)



1. **SQL 쿼리 작성:** 개발자가 SQL 문장을 작성합니다.
2. **SQL 파서:** SQL 문장은 SQL 파서에 의해 분석되고 구문 트리로 변환됩니다.
3. **최적화기:** 최적화기는 구문 트리를 분석하여 가장 효율적인 실행 계획을 생성합니다. ( 여러 인덱스 중 효율적인 인덱스 선택,  적절한 작업 순서 선택 ) 
4. **실행 엔진:** 최적화된 실행 계획에 따라 데이터베이스 엔진이 실제 데이터를 읽거나 수정하여 결과를 생성합니다.
5. **결과 반환:** 실행된 결과가 클라이언트로 반환되어 사용자에게 제공됩니다.

---

1. 구문 분석(Parsing)
    - 해당 쿼리가 문법적으로 틀리지 않은지 확인. 해당 구문을 SQL 서버가 이해할 수 있는 단위들로 분해하는 과정.
    - 만약 구문이 부정확하다면 여기서 처리를 중단. 이 문장이 일괄 처리(batch) 내에 있다면 일괄 처리 전체를 중단.(Batch abort : Batch 중 하나라도 syntax error가 있다면 전체 batch가 실행되지 않는다.)
2. 표준화(Standardization)
    - 실제로 필요없는 부분들이 제거. 표준화된 쿼리 트리(Standard Query Tree)가 만들어 진다.
3. 최적화(Optimization)
    - 통계나 조각 정보 등을 바탕으로 실행 계획을 만들어 낸다. 쿼리처리에서 매우 중요한 단계① 쿼리 분석 : 검색 제한자(SARG)인지 조인 조건인지 판단.② 인덱스 선택 : 분포 통계 정보를 이용하여 인덱스검색이나 테이블 스캔 중의 하나를 선택. 여러 인덱스 중 가장 효율적인 인덱스를 선택③ 조인 처리 : JOIN, UNION, GROUP BY, ORDER BY 절을 가지고 있는지 확인하여 적절한 작업 순서를 선택
    - 이 단계의 출력은 실행 계획(Execution Plan) 이다.
4. 컴파일(Compilation)
    - 컴파일을 하면 이진 코드가 생성된다. 일반적인 경우에는 컴파일하고 나면 .exe, .dll 등의 이진 파일이 만들어 지는데, SQL Server에서는 그냥 메모리(프로시저 캐시)에만 올린다. 그래서 컴파일 속도가 매우 빠르다.
5. 실행(Execute)
    - 엑세스 루틴으로 가서 실제 처리를 하고 결과를 돌려준다.

---

# DML은 무엇인가요? 어떤 구문이 있는지도 설명해주세요.

**Data Manipulate Language의 약자로** 테이블에 새 데이터를 삽입(INSERT)하거나, 테이블에 저장된 데이터를 수정,삭제,검색 하는 기능을 제공하는 데이터 조작어입니다. 주요 구문은 다음과 같습니다.

- **SELECT:** 데이터 조회
- **INSERT:** 새로운 데이터 삽입
- **UPDATE:** 기존 데이터 갱신
- **DELETE:** 데이터 삭제

# DDL은 무엇인가요? 어떤 구문이 있는지도 설명해주세요.

**Data Definition Language** 의 약자로 **테이블을 생성,변경,삭제** 하는 기능을 제공하는 데이터 정의어 입니다. 

DML은 데이터를 검색, 삽입, 갱신 및 삭제하는 데 사용되는 SQL 구문입니다. 주요 구문은 다음과 같습니다.

- **CREATE:** 테이블, 뷰 등을 생성
- **ALTER:** 테이블 구조 변경
- **DROP:** 테이블, 뷰 등을 삭제

# DCL은 무엇인가요? 어떤 구문이 있는지도 설명해주세요.

**Data Control Language의 약자로서** 보안을 위해 데이터에 대한 접근 및 사용 권한을 부여 및 취소하는 기능을 지닌 **데이터 제어어입니다.** 주요 구문은 다음과 같습니다.

- **GRANT:** 사용자에게 특정 권한 부여
- **REVOKE:** 사용자의 권한 취소

# INNER JOIN과 OUTER JOIN의 차이점에 대해서 설명해주세요.

**INNER JOIN에서는** 조인속성의 값이 일치하는 투플만 결과에 포함되지만,

**OUTER JOIN에서는** 조인 속성 값이 같은 투플이 상대 릴레이션에 존재하지 않아도 매칭되는 속성 값이 없는 투플을 NULL로 채워서 반환하는 연산입니다. 

# LEFT OUTER JOIN, RIGHT OUTER JOIN에 대해서 설명해주세요.

모두 OUTER JOIN 의 일종으로서, **LEFT OUTER JOIN은** 왼쪽에 있는 릴레이션에 존재하는 모든 투플을 결과 릴레이션에 포함시키고, **RIGHT OUTER JOIN은** 오른쪽에 있는 릴레이션에 존재하는 모든 투플을 결과 릴레이션에 포함시킵니다. 

# CROSS JOIN에 대해서도 설명해주세요.

두 테이블 간의 모든 가능한 조합을 반환한 것으로 카티션 프로덕트라고도 합니다.  

결과 릴레이션의 카디널리티(행 개수)는 두 테이블의 각 행의 개수를 곱한 수만큼 됩니다.

# 참조 무결성에 대해서 설명해주세요.

참조 무결성은 관련된 테이블의 레코드 간의 관계를 유효하게 하는 규칙입니다. 

참조 무결성을 위반하지 않으려면 참조하는 테이블의 왜래키 값이 참조당하는 쪽 테이블에 존재하는 값이어야 합니다. 

예를 들어 주문 테이블의 주문고객이 고객 테이블을 참조하는 Foreign key이고 그 값이 'client'이면 실제로 고객 테이블에 'client' 라는 고객이 반드시 존재해야 함을 보장하는 규칙입니다. 

참조무결성은 사용자의 실수로 관련 데이터가 삭제되거나 수정되는 것을 막아줍니다. 

# CASCADE 설정에 대해서 설명해주세요.

특정 값을 수정, 삭제 하려고 할때 해당 값을 참조하고 있는 레코드가 있을 경우 일반적으로 참조 무결성 제약 조건에 위배되어 명령을 거부하지만 **Cascading 옵션을 통해 참조 무결성이 깨지지 않도록 자동으로 해당 값을 참조하고 있는 레코드 역시 종속적으로 업데이트하거나 삭제할 수 있도록 도와줍니다.**  예를 들어, ON DELETE CASCADE는 관련 투플을 함께 삭제하고, ON UPDATE CASCADE는 관련 투플을 함께 업데이트 하도록 합니다.

# VIEW에 대해서 설명해주세요.

기본 테이블을 들여다볼 수 있는 창 역할을 하는 가상 테이블 입니다.

기본 테이블과 다르게 데이터를 실제로 저장하고 있지 않으며

필요한 데이터만을 포함한 VIEW를 생성함으로써 사용자에게 필요한 정보만을 노출시키고

조인문의 사용 최소화로 사용상의 편의성을 최대화하는 역할을 합니다. 

# SELECT 절의 처리순서에 대해서 설명해주세요.


![Untitled (5)](https://github.com/flowersayo/-CS-/assets/86418674/d573c3c0-c34d-4d11-8a9e-6e046692670e)

1. **쿼리의 가정 첫번째 실행 순서는 FROM절** 입니다. FROM 절에서는 **전체 테이블의 결과**를 갖고 옵니다.
2. WHERE 절에서는 FROM절에서 읽어온 테이블에서 **조건에 맞는 결과만 갖도록** 데이터를 간추립니다.
3. GROUP BY 절에서는 WHERE 조건으로 간추린 데이터를 **선택한 칼럼으로 GROUPING 작업**을 한 결과를 갖고 있습니다.
4. HAVING 절은 **GROUP BY된 이 후 사용되는 조건 절**입니다.

# SELECT ~ FOR UPDATE 구문에 대해서 설명해주세요.

**동시성 제어를 위하여 특정 데이터(ROW)에 대해 베타적 LOCK을 거는 기능**입니다. 

조금 더 쉽게 말하자면 데이터를 수정하기 위해서 조회하는 중에는 다른 트랜잭션이 동시에 해당 행에 접근하지 못하도록 막는 기능입니다.

예를 들어서 영화관의 영화 예매 테이블이 있다고 가정합니다.

![Untitled (6)](https://github.com/flowersayo/-CS-/assets/86418674/23c784c1-72e0-4edf-a249-0ff9d2691ac1)
![Untitled (7)](https://github.com/flowersayo/-CS-/assets/86418674/81a95d5a-6987-4b53-b73e-56e1f95bb9c5)



⇒ 두 명이 영화 예매를 진행하기 위해서 동시에 잔여 좌석을 조회한다고 치면, 
한 명의 수정이 완료되기 전에 조회가 일어나 영화 예매가 진행되었지만 잔여좌석은 1만 줄어들게 되는 상황이 발생할 수 있습니다. 

![Untitled (8)](https://github.com/flowersayo/-CS-/assets/86418674/0c0a7acd-93c9-47bc-a5c2-0744b6bd1b3e)

그러나 이번에는 A 사용자가 SELECT ~ FOR UPDATE를 실행하여 잔여 좌석정보를 SELECT 했고 해당 ROW는 다른 세션들이 접근할 수 없는 LOCK이 걸립니다. 이때 B가 SELECT로 접근하려 해도 A가 LOCK을 가지고 있기에 A가 LOCK을 풀어줄 때까지 대기상태에 빠집니다.

출처:

https://dololak.tistory.com/446

[코끼리를 냉장고에 넣는 방법:티스토리]


# GROUP BY절에 대해서 설명해주세요.

테이블에서 **특정 속성의 값이 같은 투플을 모아 그룹을 만들고**, 그룹 별로 검색 결과를 출력 하기 위해 GROUP BY 키워드를 사용한다. HAVING 키워드를 통해서 그룹에 대한 조건을 추가할 수 있습니다.

예를 들어, 주문 테이블에서 주문 제품별 수량의 합계를 검색할 경우, 주문 제품 별로 총 주문 수량을 누계하여 결과 테이블을 받아 볼 수 있습니다.

! 그룹별로 검색할 때는 집계 함수 혹은 기준 속성 외는 SELECT 절에 사용할 수 없다. 그룹 별로 특정 연산을 취해서 결과를 반환하는 것이기 때문이다. 

# ORDER BY절에 대해서 설명해주세요.

결과 테이블의 내용을 사용자가 원하는 순서로 출력하기 위해 ORDER BY 키워드를 사용합니다.

```sql
SELECT column1, column2, ...
FROM table_name
ORDER BY column1 [ ASC | DEC ] ;
```

# 서브쿼리에 대해서 설명해주세요.

SELECT 문 안에 또 다른 SELECT 문을 포함할 수 있는데, 이를 서브 쿼리라고 합니다. 

# DROP, TRUNCATE, DELETE에 각각에 대해 설명해주세요. 어떤차이가 있나요?

**DELETE** 는 WHERE절을 사용하여 특정 조건을 만족하는 투플을 선택적으로 제거하는 방식입니다. 

반면 **TRUNCATE** 는 개별적으로 행을 삭제할 수 없고, 항상 테이블의 모든 행을 제거하여 테이블을 초기화합니다. 트랜잭션 로그에 덜 기록되기 때문에 DELETE 보다 빠르게 동작하나, 롤백이 불가능하고 실행 즉시 커밋되는 등 트랜잭션을 사용할 수 없다는 특징이 있습니다. 

**DROP** 은 테이블 및 해당 테이블과 관련한 데이터( 테이블 구조, 제약조건, 인덱스, 트리거 등 )를 모두 삭제하는 방식입니다. 

# DISTINCT에 대해서 설명해주세요. 사용해본 경험도 설명해주세요.

결과 테이블에서 **투플의 중복을 제거하고 한 번씩만 출력**되도록 하려면 DISTINCT 키워드를 사용합니다. 
제품 테이블에서 제조업체 속성을 중복 없이 검색할 때 사용할 수 있습니다. 

# SQL Injection 공격이 무엇인지 어떻게 공격을 예방할 수 있는지 설명해주세요.

악의적인 사용자가 보안상의 취약점을 이용하여, 임의의 SQL 문을 주입하고 실행되게 하여 데이터베이스가 비정상적인 동작을 하도록 조작하는 행위 입니다.
![Untitled (9)](https://github.com/flowersayo/-CS-/assets/86418674/823386b5-f9f8-42cd-ad33-c0eadaa875fb)



1. **입력 값에 대한 검증**
    
    SQL Injection 에서 사용되는 기법과 키워드는 엄청나게 많습니다. 사용자의 입력 값에 대한 검증이 필요한데요. 서버 단에서 화이트리스트 기반으로 검증해야 합니다.
    
2. **Prepared Statement**
    
    Prepared Statement 구문을 사용하게 되면 사용자 입력 값을 쿼리에 직접 삽입하는 대신, 파라미터로 처리할 수 있게 됩니다. 이로써 SQL 쿼리가 실행될 때 사용자 입력이 SQL 코드로 해석되지 않아 SQL injection 공격을 방지합니다. 
    
    ```sql
    **// 사용자로부터의 입력
    String userInput = request.getParameter("username");
    
    // Prepared Statement 사용
    String sql = "SELECT * FROM users WHERE username = ?";
    try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
        pstmt.setString(1, userInput);
        ResultSet resultSet = pstmt.executeQuery();
    }**
    ```
    
3. **Error Message 노출 금지**
    
    공격자가 SQL Injection을 수행하기 위해서는 데이터베이스의 정보(테이블명, 컬럼명 등)가 필요합니다. 데이터베이스 에러 발생 시 따로 처리를 해주지 않았다면, 에러가 발생한 쿼리문과 함께 에러에 관한 내용을 반환헤 줍니다. 여기서 테이블명 및 컬럼명 그리고 쿼리문이 노출이 될 수 있기 때문에, 데이터 베이스에 대한 오류발생 시 사용자에게 보여줄 수 있는 페이지를 따로 제작하거나 메시지박스를 띄우도록 하여야 합니다.
    

# 알고 있는 SQL 안티패턴이 있다면 설명해주세요.

1. **`SELECT *`**을 사용하는 것입니다. 모든 열을 선택하는 것은 불필요한 데이터를 가져올 수 있으며 성능에 영향을 미칠 수 있습니다. 대신 필요한 열만 선택하는 것이 좋습니다.

이 쿼리는 테이블의 구조가 변경되거나 컬럼이 추가되면 예상치 못한 결과를 가져올 수 있습니다.

```sql
SELECT * FROM users; -- 안티 패턴
SELECT id, name, email FROM users; -- 권장
```

2. 문자열 연결로 동적 쿼리를 생성하면 입력값을 검증하지 않고 쿼리에 포함시키므로 SQL 인젝션 공격에 노출될 수 있습니다.

따라서 문자열 연결 대신 파라미터화된 쿼리나 저장 프로시저를 사용하는 것이 좋습니다.

```sql
name = request.getParameter("name");
sql = "SELECT * FROM users WHERE name = '" + name + "'"; -- 안티 패턴
stmt = conn.createStatement();
rs = stmt.executeQuery(sql);

name = request.getParameter("name");
sql = "SELECT * FROM users WHERE name = ?"; -- 권장
pstmt = conn.prepareStatement(sql);
pstmt.setString(1, name);
rs = pstmt.executeQuery();
```

참고 : https://engineer-mole.tistory.com/380

# 페이지네이션을 구현한다고 했을때 쿼리를 어떻게 작성해야할까요?

우선 페이지네이션이란, 페이지네이션이란 여러개의 컨텐츠를 여러 페이지로 나누어 페이지에 걸맞는 
데이터 목록을 보여주는 기능입니다. 따라서 다음의 두 데이터가 필요합니다.

- 한 페이지에 보여주고자 하는 컨텐츠의 개수
- 페이지 번호

이 때, **`LIMIT`** 및 **`OFFSET`**을 사용하여 특정 범위의 결과를 가져올 수 있습니다. 예를 들면, **`LIMIT 10 OFFSET 20`**은 21번째부터 30번째까지의 결과를 가져옵니다.

```sql
SELECT *
FROM table
WHERE {condition}
LIMIT {contents 개수} OFFSET {page number}
```

따라서 LIMIT = `한 페이지에 보여주고자 하는 컨텐츠의 개수` 로 설정하고, **`OFFSET` =**  `한 페이지에 보여주고자 하는 컨텐츠의 개수` * **`페이지 번호` 로 설정하여 특정 페이지의 데이터 목록을 받아올 수 있습니다.**

이외에도 커서 방식, 무한 스크롤 방식 등이 있습니다.
