# 랜덤 I/O와 순차 I/O에 대해서 설명해주세요.

우선, `랜덤 I/O(Random I/O, direct accss)` 는 데이터를 임의의 위치에서 읽거나 쓰는 것을 의미합니다. 순서나 위치에 상관없이 필요한 부분을 직접 찾아서 I/O 작업을 수행합니다. 데이터를 연속된 순서대로 읽거나 쓰는 것을 의미합니다. 한 번에 하나의 레코드나 블록을 읽거나 쓴 후 다음 레코드나 블록으로 이동합니다. 

HDD에서 랜덤 I/O는 디스크 헤드의 이동 시간이 많이 걸리므로 순차 I/O보다 느린 반면, SSD와 같은 플래시 메모리 기반의 디스크는 랜덤 I/O와 순차 I/O의 성능 차이가 크지 않습니다.

DB 서버에서 `순차 I/O`와 `랜덤 I/O`가 발생하는 상황은 아래와 같습니다.

## 순차 I/O

- 테이블의 모든 데이터를 조회하는 상황
- 대량의 데이터를 정렬하거나 그룹화 하는 상황
- 풀 테이블 스캔

## 랜덤 I/O

- WHERE 절(조건)이 포함된 쿼리를 실행해 데이터를 조회하는 상황
- WHERE 절(조건)이 포함된 쿼리를 실행해 데이터를 삭제하거나 수정하는 상황
- 인덱스 레인지 스캔

디스크의 성능은 헤드의 이동 없이 얼마나 많은 데이터를 순차적으로 저장하느냐에 달려있습니다.

따라서 랜덤 I/O를 줄이면 데이터베이스의 성능을 향상시킬 수 있고 

 `쿼리를 처리하는데 꼭 필요한 데이터만을 읽고 쓰도록 쿼리를 개선하는 것을 쿼리튜닝이라고 합니다.`

[https://velog.io/@yoonuk/데이터베이스-순차-IO와-랜덤-IO](https://velog.io/@yoonuk/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%88%9C%EC%B0%A8-IO%EC%99%80-%EB%9E%9C%EB%8D%A4-IO)

# 인덱스에 대해서 설명해주세요.

추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조입니다. 

원하는 내용을 찾기 쉽도록 책에 맨 앞에 목차를 추가하는 것처럼 데이터를 빠르게 조회할 수 있도록 돕습니다.
![Untitled (24)](https://github.com/flowersayo/-CS-/assets/86418674/63071840-d89b-44ef-8af2-759ed92be97e)

```sql
CREATE INDEX USER_COMPANY_INDEX ON USER(COMPANY_ID);
```

Index는 데이터의 주소값을 저장합니다. 만일 USER 테이블의 `COMPANY_ID` 컬럼에 대한 Index가 존재한다면, 예시 쿼리를 수행할 때 테이블 전체를 탐색하지 않고 Index 맵핑 테이블을 바탕으로 원하는 데이터의 위치를 빠르게 검색합니다. 

https://tecoble.techcourse.co.kr/post/2021-09-18-db-index/

# 인덱스의 동작 방식에 대해서 설명해주세요.

기본적으로 Non Clustered Index 에서 먼저 주소값을 구하고 Clustered Index 에서 다시 데이터를 구합니다.
![Untitled (25)](https://github.com/flowersayo/-CS-/assets/86418674/47a6d052-4d91-4cef-997c-63f35ed18c24)

1. 인덱스 검색 

우선, 인덱스 키를 기준으로 B-Tree에서 leaf node까지 찾아 내려간 후 해당 데이터가 위치한 주소를 알아냅니다. 

2. 디스크 I/O

 이후 해당 데이터를 찾기위해 disk로 접근한다.

우선 root node로 가서 `age = 22`인 값의 leaf노드로 가기위한 경로를 안내받는다.

root node는 branch node의 경로를 안내해주고 (branch node가 없어서 root node 바로 아래 leaf node가 있다면 바로 leaf node의 위치를 알려줄 것이다.) branch node로 가면 또 아래의 branch node혹은 leaf node의 경로를 알려줄 것이다.

그렇게 leaf node까지 도착하게 되면 leaf node는 index 의 값과 디스크의 주소값을 가지고 있다.

# 어떤 기준으로 인덱스를 설정해야할까요?

일반적으로 카디널리티가 낮고 활용도가 높은 컬럼을 **우선적으로 인덱싱하는 것이 검색 성능에 유리**합니다.

카디널리티란 **컬럼의 고유한 값의 개수를 나타내는 수치입니다.** 

- 남-여 등 2가지 값만 존재하는 성별 컬럼은 **중복도가 높으며 카디널리티가 낮습니다.**
- 개인마다 고유한 값이 존재하는 주민번호 컬럼은 **중복도가 낮으며 카디널리티가 높습니다.**

# 테이블에 인덱스를 많이 설정하면 좋을까요?

그러나 무턱대고 인덱스를 많이 설정하는게 항상 검색 속도를 향상하지는 않습니다. 

인덱스 설정에는 메모리 저장 공간이 필요할 뿐더러,

앞서 살펴본 Index 트리 자료 구조는 값이 추가 혹은 삭제될 때마다, 트리 균형을 위해 트리 구조의 재분배 및 합병 등 복잡한 연산 과정의 **오버헤드가 성능을 저하할 수 있기 때문입니다.** 

따라서 인덱스를 생성 시 해당 테이블의 의도를 정확하게 파악한 후에 상황에 맞게 적절한 칼럼으로 인덱스를 구성해야 합니다.

# 커버링 인덱스(Covering index)에 대해서 설명해주세요.

**쿼리의 모든 항목이 인덱스 컬럼으로 이루어지면** 자동으로 커버링 인덱스가 적용됩니다. 

예를 들어 (A, B) 컬럼으로 인덱스를 구성한 경우

조회 쿼리를 작성할 때, 이러한 인덱스 적용 조건을 잘 숙지하여 `커버링 인덱스`를 활용하면 성능 개선에 도움을 줄 수 있다.

`SELECT * FROM table WHERE A = ?` 와 같은 형식으로 쿼리를 사용하면 인덱스를 탄 후에 전체 컬럼값을 모두 구하기 위해 테이블에 접근합니다.

하지만 `SELECT A, B FROM table WHERE A = ?` 와 같이 구하려는 컬럼값이 모두 인덱스에 이미 존재한다면 테이블에 다시 접근할 필요가 없습니다.

인덱스는 기본적으로 Non Clustered Index 에서 먼저 값을 구하고 Clustered Index 에서 다시 데이터를 구합니다.

여기서 커버링 인덱스가 사용되었다는건 Clustered Index 까지 통하지 않고 Non Clustered Index 만으로도 데이터를 구할 수 있다는 뜻입니다.

# 다중 컬럼 인덱스(Multi-column index, 복합 인덱스)에 대해서 설명해주세요.

2개 이상의 컬럼을 포함하는 인덱스를 의미합니다. 

Q. **여러 컬럼으로 인덱스를 잡는다면 어떤 순서로 인덱스를 구성**해야 할까요?

**다중 컬럼 인덱스 내 컬럼의 순서는 성능에 큰 영향을 미칠 수 있으므로 어떤 방식의 조회가 자주 일어나는지, 필터링이 어떻게 될 지 고민해야 한다.**

 다중 컬럼 인덱스에서 선행하는 컬럼에 대한 조건을 WHERE문에 포함하지 않는다면 인덱스를 사용할 수 없다.

# B-Tree 인덱스와 B+Tree 인덱스에 대해 설명해주세요.

## B-Tree 인덱스
![Untitled (26)](https://github.com/flowersayo/-CS-/assets/86418674/87bda4e9-220b-4779-82d8-950c9884ccab)


 B트리는 이진트리에서 발전되어 **모든 리프노드들이 같은 레벨을 가질 수 있도록** 자동으로 벨런스를 맞추는 트리입니다.

B-Tree 기반의 DB Index는 특정 컬럼의 값(Key)에 해당하는 노드에 **데이터의 위치(Address)**를 저장합니다. 

---

- 장점
    - B-Tree의 Key-Value 값들은 항상 Key를 기준으로 오름차순 정렬입니다. 이로 인해 부등호 연산(>, <)에 대해 해시 테이블보다 효율적인 데이터 탐색이 가능합니다.
    - 또한 B-Tree는 **균형 트리**(Balanced Tree)이므로 평균 시간 복잡도가 O(logN)임을 보장합니다.

- 단점
    - 그러나 Index가 적용된 테이블에 데이터 갱신(INSERT, UPDATE, DELETE)이 반복되다보면, 트리의 균형이 깨지면서 성능이 악화됩니다.
    - 순차 검색의 경우 중위 순회를 하기 때문에 효율이 좋지 않습니다.

이러한 연유로 B-Tree를 확장 및 개선한 B+Tree를 Index의 자료 구조로 사용합니다.
![Untitled (27)](https://github.com/flowersayo/-CS-/assets/86418674/0664e953-a554-4f3c-ac58-f68d355e5a04)

B+Tree는 B-Tree를 확장 및 개선한 자료 구조로서, **말단의 리프 노드에만 데이터의 위치(Value)를 관리**합니다.  

- 장점
    - 중간 브랜치 노드에 Value가 없어서 B-Tree보다 메모리를 덜 차지하는 만큼, 노드의 메모리에 더 많은 Key를 저장할 수 있습니다.
    - 말단의 리프 노드들끼리는 LinkedList 구조로 서로를 참조 하고 있습니다. 부등호(>, <)를 이용한 순차 검색 연산을 하는 경우, 많은 노드를 방문해야 하는 B-Tree에 비해 B+Tree는 말단 리프 노드를 저장한 LinkedList를 한 번만 탐색하는 등 속도 이점이 있습니다.
    - 아울러 하나의 노드에 더 많은 Key를 저장하는 만큼 트리의 높이가 더 낮아집니다.


[https://velog.io/@emplam27/자료구조-그림으로-알아보는-B-Tree](https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree)

# Hash 인덱스에 대해서 설명해주세요.
![Untitled (29)](https://github.com/flowersayo/-CS-/assets/86418674/648dbd91-7f9b-476c-96d7-479688e2f21a)

해시 테이블은 Key-Value로 이루어진 데이터를 저장하는데 특화된 자료 구조입니다. 해시 테이블 기반의 DB Index는 특정 컬럼의 값과 데이터의 위치를 Key-Value로 사용합니다. 해시 테이블은 내부에 **버켓**이라고 하는 배열이 존재합니다. 해시 함수를 통해 Key를 고유한 해시 값으로 변환시키는데, 이를 버켓 배열의 인덱스로 사용하며 해당 인덱스에 Value를 저장합니다. 

Key 값으로 Value가 저장되어 있는 위치(주소)를 바로 산출할 수 있기 때문에, 해시 테이블의 평균적인 시간 복잡도는 O(1)입니다. 하지만 해시 함수를 제대로 정의하지 않으면 해시 함수를 통해 산출한 해시 값이 중복되는 해시 충돌이 발생하여 일반 순차 탐색과 다를바가 없을 수 있습니다. 또한 해시 테이블은 내부 데이터들이 정렬되어 있지 않아 탐색이 효율적이지 않습니다.

# 클러스터링 인덱스에 대해서 설명해주세요.



**클러스터링 인덱스(Clustered Index)**는 **데이터베이스 테이블의 물리적인 저장 순서를 인덱스의 순서와 일치시키는 인덱스**입니다. 클러스터링 인덱스를 사용하면 테이블의 데이터가 실제로 클러스터링되어 인덱스 순서대로 물리적으로 저장되기 때문에 일부 쿼리 성능이 향상될 수 있습니다.

- 테이블 당 하나만 설정 가능하다.
- 데이터 페이지 전체를 다시 정렬하므로, 업무시간에 클러스터링 인덱스를 생성하는 것은 심각한 부하를 줄 수 있다.
- Clustered Index는 개발자가 설정하는 Index가 아닌 MySQL이 자동으로 설정하는 Index이다.
- 당 테이블에 Auto increments 값으로 PK가 있다면 해당 컬럼이 Clustered Index가 된다.
- 만약 해당 PK가 없다면 컬럼 중에 Unique컬럼을 Clustered Index로 선정한다.

클러스터링 인덱스를 사용하는 상황

클러스터링 인덱스는 특정 상황에서 데이터베이스 성능을 향상시킬 수 있습니다. 다음은 클러스터링 인덱스를 사용하는 일반적인 상황들입니다:

1. **범위 쿼리와 정렬이 자주 사용되는 경우:**
    - 클러스터링 인덱스는 데이터를 물리적으로 정렬하기 때문에 범위 쿼리나 정렬이 자주 사용되는 경우에 성능을 향상시킬 수 있습니다. 예를 들어, 날짜 범위에 대한 검색이나 정렬된 결과를 요구하는 쿼리에서 클러스터링 인덱스는 효과적일 수 있습니다.
2. **컬럼을 기반으로 한 조인이 자주 발생하는 경우:**
    - 클러스터링 인덱스는 데이터를 물리적으로 정렬하므로 조인 연산에서 성능을 향상시킬 수 있습니다. 특히 조인 조건에 해당하는 클러스터링 인덱스가 있는 경우 해당 컬럼을 기반으로 한 조인이 효과적으로 수행됩니다.
3. **테이블의 데이터가 자주 갱신되지 않는 경우:**
    - 클러스터링 인덱스를 사용하면 테이블의 데이터가 클러스터링 인덱스에 따라 물리적으로 정렬되기 때문에 데이터의 갱신이 적은 테이블에서 성능이 향상될 수 있습니다. 데이터가 자주 갱신되는 OLTP(On-Line Transaction Processing) 환경에서는 주의가 필요합니다.
4. **테이블에 대한 범용적인 검색이 필요한 경우:**
    - 클러스터링 인덱스는 데이터를 물리적으로 정렬하기 때문에 여러 컬럼에 대한 범용적인 검색에 유용할 수 있습니다. 쿼리에서 여러 컬럼에 대한 검색이나 정렬이 일반적인 경우 클러스터링 인덱스를 고려할 수 있습니다.
5. **테이블에 대한 범용적인 읽기 작업이 많은 경우:**
    - 클러스터링 인덱스는 읽기 작업에 대한 성능을 향상시킬 수 있습니다. 데이터를 물리적으로 정렬하고, 범위 쿼리나 정렬이 자주 사용되는 상황에서 읽기 작업이 더 효율적으로 수행될 수 있습니다.
![Untitled (29)](https://github.com/flowersayo/-CS-/assets/86418674/faaa052f-51da-4c94-8aea-271b26716153)

[[Real MySQL] 클러스터링 인덱스](https://12bme.tistory.com/149?category=682920)

# 인덱스 스캔 방식에 대해서 설명해주세요.

1. **Index Range Scan**
    
    B-tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식입니다. 인덱스 루트에서 리프 블록까지 수직적 탐색을 하고, 필요한 범위만큼 수평적 탐색하는 스캔 방식입니다.
    

1. **Index Full Scan**
    
    수직적 탐색 없이 **인덱스 리프 블록 처음부터 끝까지 수평적으로 탐색하는 방식**입니다. 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택됩니다.
    
    인덱스가 차지하는 면적은 테이블이 차지하는 면적보다 훨씬 적습니다. 인덱스 스캔 단계에서 대부분 레코드를 필터링하고 아주 일부만 테이블 액세스할 수 있다면, Table Full Scan보다 Index Full Scan 방식이 유리합니다.
    
2. **Index Unique Scan**
    
    Index Unique Scan은 수직적 탐색으로만 데이터를 찾는 스캔 방식입니다. Unique 인덱스를 '=' 조건으로 탐색하는 경우에 동작합니다. Unique 인덱스가 존재하는 컬럼은 중복 값이 존재하지 않습니다. 따라서 동일('=')하다는 조건으로 검색할 때, 데이터를 한 건 찾고 나서는 더 이상 탐색할 필요가 없습니다.
    

https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=gglee0127&logNo=221336088285

![Untitled (30)](https://github.com/flowersayo/-CS-/assets/86418674/a77882fe-e983-4661-9de7-28bad9cb70d0)

데이터양이 많아질수록 full scan보다 index scan이 더 빠르다.

# 쿼리 실행 계획에 대해서 설명해주세요. 실행 계획을 확인해본적이 있나요?

쿼리 실행 계획(Query Plan)은 데이터베이스 관리 시스템(DBMS)이 SQL 쿼리를 처리하기 위해 사용하는 실행 계획이다.

**즉, SQL을 실행하는데 있어 사용되는 cost와 어떠한 방식이 가장 적절한지 판단하고, 올바른 플랜 중 평가하여 어떠한 순서와 방식으로 처리할 것인지 계획을 세우고 필요에 따라 변경하여 성능을 개선하는데 사용된다.**

이를 통해 DBMS는 쿼리 실행에 필요한 최소한의 리소스를 사용하면서 최적의 성능을 제공할 수 있다.

```sql
EXPLAIN
SELECT *
FROM board.member m
WHERE m.member_id < 10;
```
![Untitled (31)](https://github.com/flowersayo/-CS-/assets/86418674/5306f37d-794e-4efa-b1c4-838167ca79c6)


- `type`: 레코드를 어떤 방식으로 읽었는지 나타낸다.
- `key`: 최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다.
- `Extra`: 내부적인 알고리즘에 대해 나타낸다.
    - `Using Index`: 커버링 인덱스를 나타낸다.

# 힌트에 대해서 설명해주세요.

옵티마이저라고 반드시 최선의 실행계획을 수립할 수는 없기 때문에, 조인이나 인덱스의 잘못된 실행 계획을 개발자가 직접 바꿀 수 있도록 도와주는 것이 힌트입니다.

# 인덱스가 잘 동작하고 있는지 어떻게 확인할 수 있을까요?

`실행 계획`을 확인하는게 제일 간단하고 효율적이다.

# 인덱스 사용시 주의해야할 점에 대해서 알려주세요.

- 다중 인덱스를 사용할 때 선두 컬럼을 포함하지 않으면 적용 되지 않습니다.
- 가공한 값에 대해서는 인덱스가 적용되지 않을 수 있으니, 그대로 사용해야 합니다.
    - `WHERE age * 10 > 20` 처럼 조회조건에 있는 컬럼을 변경하면 안됨
    - `WHERE age > 20 / 10` 처럼 컬럼을 그대로 사용해야 함

# GROUP BY 사용시 인덱스가 걸리는 조건에 대해 설명해주세요.

먼저 GROUP BY 에서 인덱스는 아래 조건에서 적용됩니다.

- GROUP BY 절에 명시된 컬럼이 **인덱스 컬럼의 순서와 같아야 한다**.
    - 아래 모든 케이스는 **인덱스가 적용 안된다**. (index: a,b,c)
    - `group by b`
    - `group by b, a`
    - `group by a, c, b`
- 인덱스 컬럼 중 **뒤에 있는 컬럼이 GROUP BY 절에 명시되지 않아도** 인덱스는 사용할 수 있다.
    - 아래 모든 케이스는 **인덱스가 적용된다**. (index: a,b,c)
    - `group by a`
    - `group by a, b`
    - `group by a, b, c`
- 반대로 인덱스 컬럼 중 **선두 컬럼이 GROUP BY 절에 명시되지 않으면** 인덱스를 사용할 수 없다
    - ex: (index: a,b,c), `group by b, c` 는 **인덱스 적용안됨**
- 인덱스에 없는 컬럼이 GROUP BY 절에 포함되어 있으면 인덱스가 적용되지 않는다.
    - ex: (index: a,b,c), `group by a,b,c,d` 는 **인덱스 적용안됨**
    

여기서 `WHERE` 조건과 `GROUP BY`가 함께 사용되면 **WHERE 조건이 동등 비교**일 경우 GROUP BY 절에 해당 컬럼은 없어도 인덱스가 적용 됩니다.

# 이름, 국가, 성별이 있는 테이블에서 인덱스를 어떻게 걸어야할까요?

- **카디널리티가 높으면(↑) 인덱스 설정에 좋은 컬럼이다. (인덱스를 통해 불필요한 데이터의 대부분을 걸러낼 수 있음.)**

카디널리티가 높다 = 한 컬럼이 갖고 있는 값의 중복도가 낮음. (= 값들이 대부분 다른 값을 가짐.)

카디널리티가 낮다 = 한 컬럼이 갖고 있는 값의 중복도가 높음. (= 값들이 거의 같은 값을 가짐 )

- **선택도가 낮으면(↓) 인덱스 설정에 좋은 컬럼이다. (일반적으로 5~10%가 적당함.)**

선택도가 높다 = 한 컬럼이 갖고 있는 값 하나로 여러 row가 찾아진다.

선택도가 낮다 = 한 컬럼이 갖고 있는 값 하나로 적은 row가 찾아진다.

-**수정 빈도가 낮으면(↓) 인덱스 설정에 좋은 컬럼이다.**

인덱스도 테이블이기 때문에, 인덱스로 지정된 컬럼의 값이 바뀌게 되면 인덱스 테이블도 새롭게 갱신되어야 하기 때문.

테이블의 구조와 어떤 종류의 쿼리가 자주 실행되는지에 따라서 인덱스를 결정해야 합니다. 일반적으로는 자주 검색되는 컬럼이나 조건에 따라 인덱스를 설정하는 것이 좋습니다.

1. **단일 컬럼 인덱스:**
- 각각의 컬럼에 대해 단일 컬럼 인덱스를 고려할 수 있습니다. 예를 들어, 이름 검색이 자주 발생한다면 이름 컬럼에 인덱스를 설정할 수 있습니다.
    
    ```sql
    sqlCopy code
    CREATE INDEX idx_name ON your_table (name);
    
    ```
    

- **`WHERE`에 자주 사용되는 컬럼에 사용하기.**
- **`LIKE`와 사용할 경우에는 %가 뒤에 사용되도록 하기. (앞에 사용되면 `Full Scan`)**
- **`ORDER BY`에 자주 사용되는 컬럼에 사용하기.**
- **`JOIN`에 자주 사용되는 컬럼에 사용하기.**
- **데이터의 변경이 잦은 컬럼에는 인덱스를 사용하지 않기.**
